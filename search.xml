<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/12/26/mysql/"/>
      <url>/2023/12/26/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="查询语句执行流程？"><a href="#查询语句执行流程？" class="headerlink" title="查询语句执行流程？"></a>查询语句执行流程？</h1><p>查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。</p><h1 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h1><p>索引是存储引擎用于提高数据库表的访问速度的一种<strong>数据结构</strong>。它可以比作一本字典的目录，可以帮你快速找到对应的记录。</p><p>索引一般存储在磁盘的文件中，它是占用物理空间的。</p><h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><p>优点：</p><ul><li><strong>加快数据查找的速度</strong></li><li>为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度</li><li>加快表与表之间的连接</li></ul><p>缺点：</p><ul><li>建立索引需要<strong>占用物理空间</strong></li><li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li></ul><h1 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h1><p>数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</p><h1 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h1><p>索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png" alt="img"></h1><h1 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h1><ul><li><p><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</p></li><li><p><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</p></li><li><p><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</p></li><li><p><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li><li><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li><p>持久性是通过 redo log （重做日志）来保证的；</p></li><li><p>原子性是通过 undo log（回滚日志） 来保证的；</p></li><li><p>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</p></li><li><p>一致性则是通过持久性+原子性+隔离性来保证；</p><hr></li></ul></li></ul><h1 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h1><ul><li><p><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</p></li><li><p><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</p></li><li><p><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</p></li><li><p><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p><hr></li></ul><h1 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h1><p>脏读、幻读、不可重复读</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p><h1 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h1><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code> 和 <code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。<ul><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p><hr><h1 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h1><p>MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li><li><strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></li></ul><hr><h1 id="为什么MYSQL采用B-树作为索引？"><a href="#为什么MYSQL采用B-树作为索引？" class="headerlink" title="为什么MYSQL采用B+树作为索引？"></a>为什么MYSQL采用B+树作为索引？</h1><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。所以，我们希望索引的数据结构能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作，因为磁盘 I&#x2F;O 操作越少，所消耗的时间也就越小。</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul><hr><h1 id="执行一条-SQL-查询语句，期间发生了什么？"><a href="#执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么？"></a>执行一条 SQL 查询语句，期间发生了什么？</h1><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><hr><h1 id="count-和-count-1-有什么区别？哪个性能最好"><a href="#count-和-count-1-有什么区别？哪个性能最好" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好"></a>count(*) 和 count(1) 有什么区别？哪个性能最好</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/af711033aa3423330d3a4bc6baeb9532.png" alt="图片"></p><h2 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h2><p>那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p><p>可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。</p><h2 id="count（-）"><a href="#count（-）" class="headerlink" title="count（*）"></a>count（*）</h2><p>**count(<code>\*</code>) 其实等于 count(<code>0</code>)**，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。</p><p>所以，<strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。</p><h2 id="优化count"><a href="#优化count" class="headerlink" title="优化count(*)"></a>优化count(*)</h2><ul><li>第一种，近似值</li></ul><p>如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。这时，我们就可以使用 show table status 或者 explain 命令来表进行估算。</p><p>执行 explain 命令效率是很高的，因为它并不会真正的去查询</p><ul><li>第二种，额外表保存计数值</li></ul><p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p><p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p><h1 id="MYSQL有哪几种锁"><a href="#MYSQL有哪几种锁" class="headerlink" title="MYSQL有哪几种锁"></a>MYSQL有哪几种锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁</li></ul><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ul><li>Record Lock，<strong>记录锁</strong>，也就是仅仅把一条记录锁上；</li><li>Gap Lock，<strong>间隙锁</strong>，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><ul><li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p><p>当发生超时后，就出现下面这个提示：</p></li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png" alt="图片"></p><ul><li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p><p>当检测到死锁后，就会出现下面这个提示：</p></li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png" alt="图片"></p><p>上面这个两种策略是「当有死锁发生时」的避免方式。</p><p>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。</p><h1 id="乐观锁和悲观锁是什么？"><a href="#乐观锁和悲观锁是什么？" class="headerlink" title="乐观锁和悲观锁是什么？"></a>乐观锁和悲观锁是什么？</h1><p>悲观锁：假定会发生并发冲突，会对操作的数据进行加锁，直到提交事务，才会释放锁，其他事务才能进行修改。实现方式：使用数据库中的锁机制。</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过。给表增加<code>version</code>字段，在修改提交之前检查<code>version</code>与原来取到的<code>version</code>值是否相等，若相等，表示数据没有被修改，可以更新，否则，数据为脏数据，不能更新。实现方式：乐观锁一般使用版本号机制或<code>CAS</code>算法实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2023/12/23/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/12/23/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><p>抽象类描述的是一种概念，比如猫、狗都是动物，类似的还有食物</p><p>接口描述的是一种特征，某些共同的事物有共同的一种特性，比如会飞的( flyable )、会跑的</p><ul><li>一个类只能继承一个抽象类，但可以实现多个接口</li><li>抽象类可以有构造器，但接口不能有构造器</li><li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的</li><li>抽象类中的抽象方法的访问类型可以是public，protected和默认类型，但接口中的抽象方法只能是public类型的</li><li>抽象类中的变量的访问类型可以任意，但接口中定义的变量只能是public static final类型</li></ul><h1 id="String-StringBuffer和StringBuilder区别"><a href="#String-StringBuffer和StringBuilder区别" class="headerlink" title="String StringBuffer和StringBuilder区别"></a>String StringBuffer和StringBuilder区别</h1><p>String不可变，如果想修改字符串，那么字符串地址也会改变</p><p>StringBuffer和StringBuilder底层是一个数组，可以直接修改字符串</p><p>StringBuffer线程安全，效率低，（加了同步锁）</p><p>StringBuilder线程不安全，效率高，java5引入的，在单线程环境下使用的，因为它的所有方法都没有被synchronized修饰，所以效率也会高一些</p><h1 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h1><ol><li>String中保存字符串的数组被<code>final</code>修饰，并且String没有对外提供或者暴露修改这个字符串的方法</li><li>String类被<code>final</code>修饰所以不能被继承，因此避免了子类破坏String的不可变</li></ol><h1 id="和equals（）的区别"><a href="#和equals（）的区别" class="headerlink" title="&#x3D;&#x3D; 和equals（）的区别"></a>&#x3D;&#x3D; 和equals（）的区别</h1><p>&#x3D;&#x3D;：如果用于比较基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等</p><p>equals（）：用来比较两个对象的内容是否相等</p><p>注：equals（）不能用于比较基本数据类型的变量，需要自己重写</p><h1 id="重写重载的区别"><a href="#重写重载的区别" class="headerlink" title="重写重载的区别"></a>重写重载的区别</h1><p>重载就是发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><h1 id="什么是泛型？有什么作用？"><a href="#什么是泛型？有什么作用？" class="headerlink" title="什么是泛型？有什么作用？"></a>什么是泛型？有什么作用？</h1><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的<strong>可读性</strong>以及<strong>稳定性</strong>。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p><h1 id="try-catch和throw的区别"><a href="#try-catch和throw的区别" class="headerlink" title="try-catch和throw的区别"></a>try-catch和throw的区别</h1><p>try catch和throw是Java中异常处理机制的重要组成部分。</p><p>try catch用于捕获异常，即在try块中执行可能会抛出异常的代码，如果发生异常，则会跳转到catch块中执行异常处理代码。</p><p>throw用于抛出异常，即在代码中手动抛出异常，可以是Java内置的异常类，也可以是自定义的异常类。当throw语句执行时，程序会立即跳转到try catch块中的catch块中执行异常处理代码。</p><p>简而言之，try catch用于捕获异常并进行处理，而throw用于手动抛出异常。   </p><h1 id="发生异常后try-catch代码会往下执行吗？throw呢"><a href="#发生异常后try-catch代码会往下执行吗？throw呢" class="headerlink" title="发生异常后try-catch代码会往下执行吗？throw呢?"></a>发生异常后try-catch代码会往下执行吗？throw呢?</h1><p>try catch是直接处理，处理完成之后程序继续往下执行，throw则是将异常抛给它的上一级处理，程序便不往下执行了。</p><h1 id="list和set实现类"><a href="#list和set实现类" class="headerlink" title="list和set实现类"></a>list和set实现类</h1><ul><li>List实现类：ArrayList, LinkedList, Vector。</li><li>Set实现类：HashSet, TreeSet, LinkedHashSet。</li></ul><h1 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h1><p><code>ArrayList</code>和<code>LinkedList</code>都是Java集合框架中的实现类，它们分别基于数组和链表的数据结构。以下是它们之间的一些主要区别：</p><ol><li><strong>底层数据结构：</strong><ul><li><code>ArrayList</code>使用动态数组实现。它的内部是一个数组，当数组容量不足时，会自动进行扩容。</li><li><code>LinkedList</code>使用双向链表实现。每个元素都包含一个指向前一个元素和一个指向后一个元素的引用。</li></ul></li><li><strong>随机访问性能：</strong><ul><li><code>ArrayList</code>支持快速的随机访问，因为它是基于数组的，可以通过索引直接访问元素。</li><li><code>LinkedList</code>在随机访问时性能较差，因为必须从链表的头部或尾部开始遍历，直到找到目标元素。</li></ul></li><li><strong>插入和删除操作性能：</strong><ul><li><code>ArrayList</code>在中间插入或删除元素时性能较差，因为需要移动数组中的元素。</li><li><code>LinkedList</code>在插入和删除元素时性能较好，因为只需要改变相邻元素的引用。</li></ul></li><li><strong>空间复杂度：</strong><ul><li><code>ArrayList</code>相对较省空间，因为它只需要存储元素值和数组容量。</li><li><code>LinkedList</code>相对较耗费空间，因为每个元素都需要额外的两个引用字段。</li></ul></li><li><strong>迭代器性能：</strong><ul><li><code>ArrayList</code>上的迭代器性能较好，因为它可以通过索引直接访问元素。</li><li><code>LinkedList</code>上的迭代器性能较差，因为必须沿着链表一个一个地移动。</li></ul></li><li><strong>适用场景：</strong><ul><li>如果需要频繁进行随机访问，使用<code>ArrayList</code>更为合适。</li><li>如果需要频繁进行插入和删除操作，特别是在集合的中间位置，使用<code>LinkedList</code>更为合适。</li></ul></li></ol><p>选择使用哪个取决于具体的使用场景和操作需求。如果不确定，通常来说，<code>ArrayList</code>是一个更通用的选择，因为它在大多数常见的操作上都表现得很好。</p><h1 id="集合容器可以列举几个吗"><a href="#集合容器可以列举几个吗" class="headerlink" title="集合容器可以列举几个吗"></a>集合容器可以列举几个吗</h1><p>Java集合框架中的集合容器可以分为三类：List、Set和Map</p><h1 id="哪些集合类是线程安全的？哪些不安全？"><a href="#哪些集合类是线程安全的？哪些不安全？" class="headerlink" title="哪些集合类是线程安全的？哪些不安全？"></a>哪些集合类是线程安全的？哪些不安全？</h1><pre><code>线性安全的</code></pre><p>Vector：只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性<br>Hashtable：使用了synchronized关键字，所以相较于Hashmap是线程安全的。<br>ConcurrentHashMap:使用锁分段技术确保线性安全，是一种高效但是线程安全的集合。<br>Stack：栈，也是线程安全的，继承于Vector。</p><p>线性不安全的<br>Hashmap<br>Arraylist<br>LinkedList<br>HashSet<br>TreeSet<br>TreeMap</p><p>Hashmap： HashMap在put操作的时候，如果插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是resize，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p><p>Arraylist： List 对象在做 add 时，执行 Arrays.copyOf 的时候，返回一个新的数组对象。当有线程 A、B… 同时进入 grow方法，多个线程都会执行 Arrays.copyOf 方法，返回多个不同的 elementData 对象，假如，A先返回，B 后返回，那么 List.elementData &#x3D;&#x3D;A. elementData,如果同时B也返回，那么 List.elementData &#x3D;&#x3D;B. elementData,所以线程B就把线程A的数据给覆盖了，导致线程A的数据被丢失。</p><p>LinkedList：与Arraylist线程安全问题相似，线程安全问题是由多个线程同时写或同时读写同一个资源造成的。</p><p>HashSet：底层数据存储结构采用了Hashmap，所以Hashmap会产生的线程安全问题HashSet也会产生。</p><h1 id="如果想要线程安全的HashMap有什么方式？"><a href="#如果想要线程安全的HashMap有什么方式？" class="headerlink" title="如果想要线程安全的HashMap有什么方式？"></a>如果想要线程安全的HashMap有什么方式？</h1><ul><li><p>HashTable 是线程安全的。HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率非常低下.</p></li><li><p>使用ConcurrentHashMap ，分段锁的思想，将 HashMap 进行切割，把 HashMap 中的哈希数组切分成小数组，每个小数组有 n 个 HashEntry 组成，其中小数组继承自ReentrantLock（可重入锁），这个小数组名叫Segment（JDK1.7）</p></li><li><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。</p></li><li><p>使用Collections.synchronizedMap方法，对方法进行加同步锁；</p></li></ul><h1 id="说下rabbitMQ的组件有哪些？"><a href="#说下rabbitMQ的组件有哪些？" class="headerlink" title="说下rabbitMQ的组件有哪些？"></a>说下rabbitMQ的组件有哪些？</h1><ul><li>Broker组件</li><li>virtual host组件</li><li>Connection组件</li><li>Channel组件</li><li>Exchange组件</li><li>Queue组件</li><li>Binding组件</li></ul><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="介绍一下IOC、"><a href="#介绍一下IOC、" class="headerlink" title="介绍一下IOC、"></a>介绍一下IOC、</h2><p>IoC （Inversion of Control ）即控制反转&#x2F;反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。</p><p>例如：现有类 A 依赖于类 B</p><ul><li><strong>传统的开发方式</strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li><li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</li></ul><p>从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情</p><h2 id="bean是只有一个还是很多个"><a href="#bean是只有一个还是很多个" class="headerlink" title="bean是只有一个还是很多个"></a>bean是只有一个还是很多个</h2><h1 id="synchronized-是什么？有什么用？"><a href="#synchronized-是什么？有什么用？" class="headerlink" title="synchronized 是什么？有什么用？"></a>synchronized 是什么？有什么用？</h1><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>不过，在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> </p><h1 id="synchronized、ReentrantLock是否可以重入，是公平锁还是非公平锁？"><a href="#synchronized、ReentrantLock是否可以重入，是公平锁还是非公平锁？" class="headerlink" title="synchronized、ReentrantLock是否可以重入，是公平锁还是非公平锁？"></a>synchronized、ReentrantLock是否可以重入，是公平锁还是非公平锁？</h1><p>都可以重入，都是可重入锁</p><p>synchronized是非公平锁</p><p>ReentrantLock可以实现公平锁和非公平锁两种。</p><h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC的方式通常有<strong>管道</strong>（包括匿名管道和命名管道 Pipe）、<strong>消息队列</strong>（MQ）、<strong>信号量</strong>（Semaphre）、<strong>共享内存</strong>（Shared memory）、<strong>信号</strong>（Signal）、<strong>套接字通信（Socket）</strong>等。</p><p><strong>进程间通信的目的</strong></p><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程</li><li>资源共享：多个进程之间共享同样的资源</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li><li>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常</li></ul><h1 id="什么是面向对象-谈谈你对面向对象的理解"><a href="#什么是面向对象-谈谈你对面向对象的理解" class="headerlink" title="什么是面向对象? 谈谈你对面向对象的理解"></a>什么是面向对象? 谈谈你对面向对象的理解</h1><p>下面是面试君对于这个面试题的回答，不一定全对，可具有一定的参考借鉴意义：</p><p>面试官你好，我来回答一下这个问题，对于什么是面向对象，它是一种编程思想。聊到面向对象，我们需要聊一下面向过程的编程方式，因为面向对象是从面向过程过渡而来的。</p><p>以实际生活的案例来举一个例子，比如说洗衣服。</p><p>如果是面向过程的话，我们会将这个洗衣服任务拆解成一系列的步骤，每一个步骤就是一个函数。</p><p>第一步，打开洗衣机；</p><p>第二步，放衣服和洗衣液；</p><p>第三步，选择洗衣模式，开始洗衣；</p><p>第四步，等待洗完，拿出衣服。</p><p>如果是面向对象的编程方式，我们会拆分成人和洗衣机两个对象，再分析每一个对象，它需要做哪些事情。</p><p>人在其中需要做这三件事：</p><p>第一件打开洗衣机</p><p>第二件是放衣服和洗衣液</p><p>第三件事是洗完衣服后拿出衣服。</p><p>洗衣机在其中只需要做一件事情：</p><p>根据洗衣模式洗衣服。</p><p>在这个例子中，我们能够看出来面向过程跟面向对象，是两种不同的思维方式，处理问题的思考的角度不一样。</p><p>面相过程的思维方式，它更加注重这个事情的每一个步骤以及顺序。他比较直接高效，需要做什么可以直接开始干。</p><p>面向对象的思维方式，它更加注重事情有哪些参与者，需求里面有哪些对象，这些对象各自需要做些什么事情。将其拆解成一个个模块和对象，这样会更易于维护和拓展。</p><p>这个是面向过程跟面向对象的区别。</p><p>面向对象的三大特性：封装、继承和多态。<br>说到面向对象的话，一定要说到它的三大特性。</p><p><strong>封装（Encapsulation）：</strong></p><ul><li>封装是面向对象编程的基本原则之一。它将类的实现细节隐藏起来，只向外部暴露必要的接口和数据。通过封装，对象内部的实现细节对外部是不可见的，这提高了代码的安全性和可维护性。封装可以通过访问修饰符（如private、protected、public）来实现，同时提供公共的方法来访问或修改私有属性。</li></ul><p><strong>继承（Inheritance）：</strong></p><ul><li>继承是一种通过重用现有类的属性和方法来创建新类的机制。子类继承父类的特性，可以使用父类中的方法和属性，同时可以在子类中扩展或修改这些方法和属性。继承实现了代码的重用，提高了代码的可维护性。Java中通过关键字<code>extends</code>来实现继承关系。</li></ul><p><strong>多态（Polymorphism）：</strong></p><ul><li>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。多态提高了代码的灵活性和可扩展性。Java中有两种类型的多态：编译时多态（静态多态）和运行时多态（动态多态）。运行时多态是通过方法的重写（Override）和接口来实现的。编译时多态是通过方法的重载（Overload）来实现的。多态是面向对象编程中一个非常重要的概念，它使得程序更容易扩展和维护。</li></ul><h1 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h1><p>以下是一些常用的Linux命令，用于在终端中执行各种任务：</p><ol><li><p><strong><code>ls</code> - 列出文件和目录：</strong></p><ul><li>用于列出当前目录下的文件和子目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>cd</code> - 切换目录：</strong></p><ul><li>用于更改当前工作目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> directory_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>pwd</code> - 显示当前工作目录：</strong></p><ul><li>用于显示当前工作目录的路径。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>cp</code> - 复制文件或目录：</strong></p><ul><li>用于复制文件或目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure></li><li><p><strong><code>mv</code> - 移动&#x2F;重命名文件或目录：</strong></p><ul><li>用于移动文件或目录，也可用于重命名。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure></li><li><p><strong><code>rm</code> - 删除文件或目录：</strong></p><ul><li>用于删除文件或目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>mkdir</code> - 创建目录：</strong></p><ul><li>用于创建新目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> directory_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>rmdir</code> - 删除空目录：</strong></p><ul><li>用于删除空目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> directory_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>cat</code> - 查看文件内容：</strong></p><ul><li>用于查看文件的内容。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>more</code> - 逐屏显示文件内容：</strong></p><ul><li>用于逐屏显示文件的内容。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>less</code> - 逐屏显示文件内容，支持向前翻页：</strong></p><ul><li>用于逐屏显示文件的内容，支持向前翻页。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>head</code> - 显示文件头部内容：</strong></p><ul><li>用于显示文件的头部内容。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>tail</code> - 显示文件尾部内容：</strong></p><ul><li>用于显示文件的尾部内容，常用于查看日志。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>grep</code> - 在文件中查找匹配的文本：</strong></p><ul><li>用于在文件中查找包含指定文本的行。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>find</code> - 在文件系统中查找文件：</strong></p><ul><li>用于在文件系统中递归查找文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find directory -name file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>chmod</code> - 修改文件权限：</strong></p><ul><li>用于修改文件或目录的权限。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> permissions file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>chown</code> - 修改文件所有者：</strong></p><ul><li>用于修改文件或目录的所有者。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> owner:group file_name</span><br></pre></td></tr></table></figure></li><li><p><strong><code>ps</code> - 显示当前运行的进程：</strong></p><ul><li>用于显示当前正在运行的进程信息。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure></li><li><p><strong><code>kill</code> - 终止进程：</strong></p><ul><li>用于终止指定的进程。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> process_id</span><br></pre></td></tr></table></figure></li><li><p><strong><code>man</code> - 查看命令手册：</strong></p><ul><li>用于查看Linux命令的手册页。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man command_name</span><br></pre></td></tr></table></figure></li></ol><h1 id="为什么要用线程池，线程池有哪几个"><a href="#为什么要用线程池，线程池有哪几个" class="headerlink" title="为什么要用线程池，线程池有哪几个"></a>为什么要用线程池，线程池有哪几个</h1><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p><hr><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p><p><img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-UftlG_nP.png" alt="通过构造方法实现"></p><p>通过构造方法实现</p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li><li>**<code>ScheduledThreadPool</code>**：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化</title>
      <link href="/2023/11/16/SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2023/11/16/SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="Insert优化"><a href="#Insert优化" class="headerlink" title="Insert优化"></a>Insert优化</h3><font size = 4>>批量插入<pre><code>insert into tb_test values(1,&#39;tom&#39;),(2,&#39;cat&#39;),(1,&#39;jerry&#39;);</code></pre><blockquote><p>手动提交事务</p></blockquote><pre><code>start transaction;insert into tb test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,Jerry&#39;);insert into tb test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6, erry&#39;);insert into tb_test values(7,&#39;Tom&#39;),(8,Cat&#39;),(9,Jerry&#39;);commit;</code></pre><blockquote><p>主键顺序插入</p></blockquote><p>主键乱序插入:8 1 9 2 1 88 2 4 15 89 5 73<br>主键顺序插入 : 1 9 15 21 88 89</p><hr><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。</p><p>客户端连接服务端时，加上参数 <code>--local-infile</code></p><pre><code>mysgl --local-infile -u root -p</code></pre><p>设置全局参数 local infile 为1，开启从本地加载文件导入数据的开关</p><pre><code>set global local infile = 1:</code></pre><p>执行load指令将准备好的数据，加载到表结构中</p><pre><code>load data local infile &#39;/root/sql.log&#39; into table tb user&#39; fields terminated by &#39;&#39; lines terminated by &#39;n&#39;</code></pre><hr><h2 id="Oeder-by优化"><a href="#Oeder-by优化" class="headerlink" title="Oeder by优化"></a>Oeder by优化</h2><p>1.<strong>Using filesot</strong>:通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区<code>sort buffer</code>中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 <code>FileSort</code>排序</p><p>2.<strong>Using index</strong>:通过有序索引顺序扫描直接返回有序数据，这种情况即为<code>using index</code>，不需要额外排序，操作效率高.</p><blockquote><p>创建索引的时候直接创建带排序的索引,根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>尽量使用覆盖索引。</p></blockquote><blockquote><p>多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则 (ASC&#x2F;DESC)。</p></blockquote><blockquote><p>如果不可避免的出现<code>fileot</code>，大数据量排序时，可以适当增大排序缓冲区大小 <code>set_ buffer_size</code>(默认256k)。</p></blockquote><hr><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><p>遵循最左前缀法则</p><hr><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>一个常见又非常头疼的问题就是 <code>limt 2000000,10</code> ，此时需要MyS0L排序前2000010 记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p>用覆盖查询，先查询出需要记录的数据的id，再把查询出的id的数据当成一张表，和原表多表联查</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><pre><code>explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;</code></pre><hr><h2 id="count-优化"><a href="#count-优化" class="headerlink" title="count 优化"></a>count 优化</h2><p>count(*)不取值，速度最快</p><hr><h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><p>lnnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁</p><p>想要修改特定字段的数据可以给该字段加索引，就可以锁住这一行</p></font>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>索引使用规则</title>
      <link href="/2023/11/15/%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/"/>
      <url>/2023/11/15/%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h1><h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h2><font size = 4>如果索引了多列(联合索引)，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列， <font color = 'red'>索引将部分失效(后面的字段索引失效)</font><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><h3 id="联合索引中，出现范围查询"><a href="#联合索引中，出现范围查询" class="headerlink" title="联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效"></a>联合索引中，出现范围查询(&gt;,&lt;)，<font color = 'red'>范围查询右侧的列索引失效</h3></font><h2 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h2><h3 id="·不要在索引列上进行运算操纵-函数），索引将失效"><a href="#·不要在索引列上进行运算操纵-函数），索引将失效" class="headerlink" title="·不要在索引列上进行运算操纵(函数），索引将失效"></a>·不要在索引列上进行运算操纵(函数），<font color = 'red'>索引将失效</font></h3><h3 id="·字符串不加引号，索引将失效"><a href="#·字符串不加引号，索引将失效" class="headerlink" title="·字符串不加引号，索引将失效"></a>·字符串不加引号，<font color = 'red'>索引将失效</font></h3><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>如果仅仅是尾部模糊匹配(xx%)，索引不会失效。如果是头部模糊匹配(%xx)，索引失效。</p><pre><code>explain select * from tb_user where profession like &quot;软件%&#39;;    索引生效explain select * from tb_user where profession like &quot;%工程&#39;;    索引失效explain select * from tb_user where profession like &quot;%工%&#39;;    索引失效</code></pre><h2 id="or链接的条件"><a href="#or链接的条件" class="headerlink" title="or链接的条件"></a>or链接的条件</h2><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><h2 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h2><p>如果MySQL评估使用索引比全表更慢，则不使用索引</p></p><pre><code>use indexignore indexforce index</code></pre><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2></font>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL约束</title>
      <link href="/2023/11/13/SQL%E7%BA%A6%E6%9D%9F/"/>
      <url>/2023/11/13/SQL%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="非空约束：-NOT-NULL"><a href="#非空约束：-NOT-NULL" class="headerlink" title="非空约束： NOT NULL"></a>非空约束： NOT NULL</h2><h2 id="唯一约束：-UNIQUE"><a href="#唯一约束：-UNIQUE" class="headerlink" title="唯一约束： UNIQUE"></a>唯一约束： UNIQUE</h2><h2 id="主键约束：-PRIMARY-KEY-自增：AUTO-INCREMENT"><a href="#主键约束：-PRIMARY-KEY-自增：AUTO-INCREMENT" class="headerlink" title="主键约束： PRIMARY KEY(自增：AUTO_INCREMENT)"></a>主键约束： PRIMARY KEY(自增：AUTO_INCREMENT)</h2><h2 id="默认约束：-DEFAULT"><a href="#默认约束：-DEFAULT" class="headerlink" title="默认约束： DEFAULT"></a>默认约束： DEFAULT</h2><h2 id="检查约束：-CHECK"><a href="#检查约束：-CHECK" class="headerlink" title="检查约束： CHECK"></a>检查约束： CHECK</h2><h2 id="外键约束：-FOREIGN-KEY"><a href="#外键约束：-FOREIGN-KEY" class="headerlink" title="外键约束： FOREIGN KEY"></a>外键约束： FOREIGN KEY</h2><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><p><font size = 4><font color = "blue"><strong>ALTER TABLE</strong> </font> 表名 <font color = "blue"> <strong>ADD CONSTRAINT</strong></font>外键名称 <font color = "blue"> <strong>FOREIGN KEY</strong></font> (外键字段)<font color = "blue"> <strong>REFERENCES</strong></font> 主表名(主表字段名)</font></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p><font size = 4><em><strong><code>alter</code></strong></em> <em><strong><code>table</code></strong></em> emp <em><strong><code>add constraint</code></strong></em> fk_emp_dept_id <em><strong><code>foregin key</code></strong></em>(dept_id) <em><strong><code>references</code></strong></em> dept(id)<br></font></p><hr><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="select-from-表1，表2-；"><a href="#select-from-表1，表2-；" class="headerlink" title="select * from 表1，表2 ；"></a>select * from 表1，表2 ；</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL查询、排序方法</title>
      <link href="/2023/11/11/SQL%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/11/SQL%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><h2 id="1、统计该企业员工数量"><a href="#1、统计该企业员工数量" class="headerlink" title="1、统计该企业员工数量"></a>1、统计该企业员工数量</h2><p><code>select count(id) from emp ;</code><br><code>select count(idcard) from emp ;  -- 不计算null值</code></p><h2 id="2、统计平均年龄"><a href="#2、统计平均年龄" class="headerlink" title="2、统计平均年龄"></a>2、统计平均年龄</h2><p><code>select avg(age) from emp ;</code></p><h2 id="3、最大年龄"><a href="#3、最大年龄" class="headerlink" title="3、最大年龄"></a>3、最大年龄</h2><p><code>select max(age) from emp ;</code></p><h2 id="3、最小年龄"><a href="#3、最小年龄" class="headerlink" title="3、最小年龄"></a>3、最小年龄</h2><p><code>select min(age) from emp ;</code></p><h2 id="4、统计北京地区员工年龄之和"><a href="#4、统计北京地区员工年龄之和" class="headerlink" title="4、统计北京地区员工年龄之和"></a>4、统计北京地区员工年龄之和</h2><p><code>select sum(age) from emp where workadress = &#39;北京&#39;</code></p><h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><h2 id="1、根据性别分组，统计男生女生人数"><a href="#1、根据性别分组，统计男生女生人数" class="headerlink" title="1、根据性别分组，统计男生女生人数"></a>1、根据性别分组，统计男生女生人数</h2><p><code>select gender,count(*) from emp group by gender;</code></p><h2 id="2、根据性别分组，统计男生女生平均年龄"><a href="#2、根据性别分组，统计男生女生平均年龄" class="headerlink" title="2、根据性别分组，统计男生女生平均年龄"></a>2、根据性别分组，统计男生女生平均年龄</h2><p><code>select gender,avg(age) from emp group by gender;</code></p><h2 id="3、查询年龄小于40的员工，并根据工作地址分组，获取员工数量大于3的工作地址"><a href="#3、查询年龄小于40的员工，并根据工作地址分组，获取员工数量大于3的工作地址" class="headerlink" title="3、查询年龄小于40的员工，并根据工作地址分组，获取员工数量大于3的工作地址"></a>3、查询年龄小于40的员工，并根据工作地址分组，获取员工数量大于3的工作地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select workadress, count(*) from emp where age &lt; 40 group by workadress having count(*) &gt;= 3;</span><br><span class="line">select workadress, count(*) address_count from emp where age &lt; 40 group by workadress having address_count &gt;= 3;  -- 起别名不用having</span><br></pre></td></tr></table></figure><h1 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h1><h2 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 **order by** 字段1 排序方式**,**字段2 排序方式</span><br><span class="line">asc : 升序  desc：降序</span><br></pre></td></tr></table></figure><h2 id="1、对员工按照年龄进行升序排序"><a href="#1、对员工按照年龄进行升序排序" class="headerlink" title="1、对员工按照年龄进行升序排序"></a>1、对员工按照年龄进行升序排序</h2><p><code>select * from emp order by age asc ; -- asc可以省略</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/10/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/10/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h1><h1 id="VSCode终端"><a href="#VSCode终端" class="headerlink" title="VSCode终端"></a>VSCode终端</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"># Cmder终端</span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
